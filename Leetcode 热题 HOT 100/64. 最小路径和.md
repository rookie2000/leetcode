## 题目地址（64. 最小路径和）

https://leetcode.cn/problems/minimum-path-sum/solutions/3045828/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-zfb2/

## 题目描述

```
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

示例 1：
```

<p>
  <img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="图片描述" width="300">
</p>

```


输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
示例 2：

输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

## 方法一

记忆化搜索，此题会超时

## 代码

```python
# 会超时的递归写法
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 想清楚最后一步发生了什么，就想清楚每一步发生了什么
        m = len(grid) - 1
        n = len(grid[0]) - 1
        # dfs(i, j)表示从左上角到第i行第j列这个格子的最小价值和
        # 看上去从右下角到左上角的最小价值和
        # 倒着思考，方便后面1:1翻译成递推
        def dfs(i: int, j: int) -> int:
            if i < 0 or j < 0:
                return inf
            if i == 0 and j == 0:
                return grid[0][0]
            return min(dfs(i - 1, j), dfs(i, j - 1)) + grid[i][j]

        return dfs(m, n)
```

## 方法二

1:1翻译成递推

## 代码

```python

```
